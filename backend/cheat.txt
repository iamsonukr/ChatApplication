running dotenv.-----------------
1> npm i dotenv
2> import 'dotenv/config' //server.js
3> file .env
4> process.env.variableName

-----------------------URL for user image -----
https://avatar-placeholder.iran.liara.run/ 

-----------Using bcrypt.js---------------

1> import bcrypt.js
2> Receive password in the res.body
3> const salt=await bcryptjs.genSalt(50)
   const hashedPassword= await bcrypt.hash(password,salt)
4> Pass password:hashedPassword in new userModel 



---------------JWT Token----------------------------

# Generate -base64 secret key in bash 
openssl rand -base64 32

Creating JWT Token 
1> import JWT and create a function to generate webtoken
 ref :- backend/utils/generateToken.utils.js

2> pass the newUser._id and the res in function. newUser._id to generate token , and res to save the token in cookie


---How it works---

you must install and import cookie parser 

import cookieParser from 'cookie-pars
app.use(cookieParser())

1> It takes the userId and the sercret key and generate the token
2> It saves the token in the cookie
3> It fetch the token from the cookie to check if the user is authenticated to perform any operation or not.

----------------ProtectRoute----------------

Functions of protectRoute

convert the token into userId by decoding it whit the help of secretKey 
assigning the req.user the user fectech fromt the db with the help of the _id decoded


---------------------------------------How messageing is working-------------------------------

we have three schema 
1> message schema
2> conversation schema 
3> user schema

STAGE 1
{
   message:hello
}
The message is being sent at this adderss [messageRouter.post("/send/:id",protectRoute,sendMessage)]  

STAGE 2

On reaching the protectRoute middleware , the token is decoded to get the sender id , receiver id is already in the params , 
On the basis of id extracted from the token a user is fetched from the database. and req.user is set to as user

STAGE 3
Inside sendMessage function we have used two schema 

conversationSchema: 
It has two arrays 

   participants: it store all the participants involved in the conversation
   messages:It store all the ids of the message that containes the follwing two participants

Message object is created and is saved in the message database 
while the conversation database has the object which contains the array of the participants and the array of ids of message sent between them.





-----------------------MongoDB Notes---------------------------

type: mongoose.Schema.Types.ObjectId:
ref:"user" //user is the name of the model mongoose.model('user',UserSchema)

This specifies that the data type of senderId is ObjectId, which is a unique identifier used by MongoDB to identify documents in a collection. 
It's the standard data type for storing document IDs.
ObjectId is a 12-byte identifier generated by MongoDB for each document. Itâ€™s used here because you want to store a reference to another
document, in this case, a user document.
ref: "User":

This sets up a reference to another schema. The ref option tells Mongoose that senderId refers to a document in the User collection.
Essentially, it creates a relationship between the current schema and the User schema. So senderId will store the _id of a document in the 
User collection.

Message.findById(messageId).populate('senderId').exec((err, message) => {
    console.log(message.senderId); // This would print the populated user document.
});



// it is extracting all except the user id not equal to loogedinId ... .select("-field you dont wnat to fetch")
const filterdUsers=await userModel.find({_id:{$ne:loggedInUserId}}).select("-password")














